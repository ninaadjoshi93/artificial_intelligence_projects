#!/usr/bin/python
# put your 15 puzzle solver here!
"""
Abstraction of the Problem:

The 15-puzzle problem provided is a modified version of the classic puzzle.
Here, the state space has changed for the puzzle in a way that movement of
multiple tiles in a row or column with the blank space is counted as one move.
Thus, the player can move either one, two or three tiles in the same column or
row as the blank space. However, there can be unsolvable combinations of the
board.Thus, the parity inversion has been calculated which is then checked with
the position of the blank space.

State space :

The state space consists of all the possible board combinations which will
result in reaching the goal state through any sequences of moves. The unsolvable
boards have been excluded from the state space using parity inversion for tiles.

A state consists of various parameters namely, the board configuration, the cost
till the state was attained from the initial state (which here is the number of
moves required), the heuristic value calculated for the states, to priority of
the state (current cost + the heuristic value calculated for the state) and the
performed move.

Successor function :

The successor function is designed to generate 6 subsequent states for any given
input state. The successors are generated by shifting either one, two or three
tiles in the same row or column as the blank space. A list of successors is
returned from the function.

Edge weights/Cost function :

The cost of transition from a state to its successor state is taken
as one move. Thus, the cost is assumed to be uniform for all successors in this
case.

Goal state :

The goal state is the final position of the tiles in the board, such as below :

    1   2   3   4
    5   6   7   8
    9   10  11  12
    13  14  15  0

In this state, the tiles are arranged in increasing order of their face values
row wise and the blank space is represented by '0'.

Heuristic function :

The heuristic used for this problem is a modified version of the manhattan
distances with the linear conflicts heuristics. Here, the moves are decided by
checking if the tiles are in their goal columns or goal rows. If the tiles are
in their intended goal positions, they are ignored. If the tiles are in their
goal columns then only the goal distance from the current position is added to
the heuristic sum. If the tiles are neither in the goal row nor the goal
column, then the manhattan distance is added to the heuristic sum. The heuristic
is admissible as the sum is incremented only once for the tiles in their goal
columns or rows, and the manhattan distance is added only for tiles which are
not in their goal rows as well as goal columns.


Description :

The code below takes a given input board configuration from a file passed as an
argument. The initial board is parsed from the file and exceptions are handled
accordingly. The initial state is a list of lists and is generated by
initializing and storing the cost value to zero, calculating the heuristic
value for the initial state, the list of generated moves for the states, the
priority of the state which is calculated by adding the cost of the current
state and the heuristic value for the state, and the board configuration of the
current state. The A* algorithm has been used to get the minimum moves required
to get to the goal state. The moves are printed once the goal is reached.

Problems faced :

A major design decision was made to skip the checking of presence of a state in
fringe as the size of the fringe was increasing. Thus, the checking time was
very high and resulted in sluggish performance.

"""

import sys
import time
import copy
import heapq

global start_time, end_time, nodes, fringe, visited

# This is the goal state configuration
goal_state = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]]

# Positions of the values in their respective goal state positions
goal_positions = {1: [0, 0], 2: [0, 1], 3: [0, 2], 4: [0, 3],
                  5: [1, 0], 6: [1, 1], 7: [1, 2], 8: [1, 3],
                  9: [2, 0], 10: [2, 1], 11: [2, 2], 12: [2, 3],
                  13: [3, 0], 14: [3, 1], 15: [3, 2], 0: [3, 3]}

def find_position(ini_state, value):
    for i in range(0, 4):
        for j in range(0, 4):
            if ini_state[i][j] == value:
                return [i, j]

def is_goal(board_state):
    return board_state == goal_state

# reference link for linear conflicts algorithm :
# https://academiccommons.columbia.edu/download/fedora_content/download/ac:141290/CONTENT/cucs-219-85.pdf
def heuristic_min_diagonal(ini_state):
    heuristic_distance = 0
    mov_row = [0] * 4
    mov_col = [0] * 4
    if ini_state == goal_state:
        return 0
    for value in range(1, 16):
        r_act, c_act = find_position(ini_state, value)
        r_goal, c_goal = goal_positions.get(value)
        r_dist = abs(r_goal - r_act)
        c_dist = abs(c_goal - c_act)
        if r_dist == 0 and c_dist == 0:
        # Tile in goal position so ignore
            continue
        elif r_dist == 0:
        # Tile in goal row so consider linear conflicts
            for i in range(r_act + 1, 4):
                temp = ini_state[i][c_act]
                if temp and not mov_col[c_act]:
                    if r_act < i and 0 < value - temp < 4:
                        heuristic_distance += c_dist
                        mov_col[c_act] = 1
        elif c_dist == 0:
            # Tile in goal column so consider linear conflicts
            for i in range(c_act + 1, 4):
                temp = ini_state[r_act][i]
                if temp and value % 4 == temp % 4 and not mov_row[r_act]:
                    if c_act < i and value > temp:
                        heuristic_distance += r_dist
                        mov_row[r_act] = 1
        else:
            heuristic_distance += (abs(r_dist) + abs(c_dist))
    return heuristic_distance

def successors(ini_state):
    r_old, c_old = find_position(ini_state[4], 0)
    temp = copy.deepcopy(ini_state[4])
    successors = []
    for i in range(0,6):
        successors.append(copy.deepcopy(ini_state))
    s_cnt = 0
    for i in range(0, 4):
        r, c = find_position(temp, 0)
        if i != c_old:
            temp[r].insert(i, temp[r].pop(c))
            successors[s_cnt][4] = copy.deepcopy(temp)
            successors[s_cnt][1] = -heuristic_min_diagonal(successors[s_cnt][4])
            successors[s_cnt][2] += 1
            successors[s_cnt][0] = successors[s_cnt][2] - successors[s_cnt][1]
            successors[s_cnt][3].append(get_move(r_old, c_old, successors[s_cnt][4]))
            s_cnt += 1
    temp = copy.deepcopy(ini_state[4])
    # Referred rotation of 2D array to get matrix transpose :
    # https://stackoverflow.com/questions/42519/how-do-you-rotate-a-two-dimensional-array
    rotated_temp = [list(element) for element in zip(*temp[::1])]
    for i in range(0, 4):
        c, r = find_position(rotated_temp, 0)
        if i != r_old:
            rotated_temp[c].insert(i, rotated_temp[c].pop(r))
            new_temp = [list(element) for element in zip(*rotated_temp[::1])]
            successors[s_cnt][4] = copy.deepcopy(new_temp)
            successors[s_cnt][1] = -heuristic_min_diagonal(successors[s_cnt][4])
            successors[s_cnt][2] += 1
            successors[s_cnt][0] = successors[s_cnt][2] - successors[s_cnt][1]
            successors[s_cnt][3].append(get_move(r_old, c_old, successors[s_cnt][4]))
            s_cnt += 1
    return successors

def get_move(r_old, c_old, new_state):
    r_new, c_new = find_position(new_state, 0)
    r_diff = r_new - r_old
    c_diff = c_new - c_old
    if r_diff < 0:
        return "D" + str(abs(r_diff)) + str(c_old + 1)
    elif r_diff > 0:
        return "U" + str(abs(r_diff)) + str(c_old + 1)
    elif c_diff < 0:
        return "R" + str(abs(c_diff)) + str(r_old + 1)
    elif c_diff > 0:
        return "L" + str(abs(c_diff)) + str(r_old + 1)

def solve_15_puzzle(initial_state):
    global start_time
    global end_time
    global nodes
    global fringe
    global visited
    # nodes = 0
    fringe = []
    visited = []
    start_time = time.time()
    if is_goal(initial_state[4]):
        end_time = time.time()
        return initial_state

    # Referred Heapq documentation to understand usage :
    # https://docs.python.org/2/library/heapq.html
    # Discussed heapq characteristics with Siddharth Pathak
    heapq.heappush(fringe, initial_state)
    while fringe:
        # nodes += 1
        current_state = heapq.heappop(fringe)
        # Discussed visited array checking with Akshay Naik
        if current_state[4] not in visited:
            visited.append(current_state[4])
        else:
            continue
        if is_goal(current_state[4]):
            end_time = time.time()
            return current_state
        for successor in successors(current_state):
            heapq.heappush(fringe, successor)
    return False

def calculate_parity_inversion(initial_board):
    parity_inversion = 0
    for i in range(0, 15):
        for j in range(i + 1, 16):
            # Referred Single For Loop traversal of 2D array :
            # https://stackoverflow.com/questions/10861800/how-to-iterate-over-a-2d-array-with-a-single-loop
            if initial_board[i / 4][i % 4] and initial_board[j / 4][j % 4] \
                    and initial_board[i / 4][i % 4] > initial_board[j / 4][
                                j % 4]:
                parity_inversion += 1
    return parity_inversion

try:
    file_input = open(str(sys.argv[1]), "r")
    initial_board = [[0] * 4] * 4
    for value, line in enumerate(file_input.readlines()):
        initial_board[value] = map(int, line.split())
    # check for validity of board by considering parity inversion
    # Referred the formula to check if the board is solvable or not :
    # https://www.cs.bham.ac.uk/~mdr/teaching/modules04/java2/TilesSolvability.html
    r, c = find_position(initial_board, 0)
    if calculate_parity_inversion(initial_board) % 2 != (r + 1) % 2:
        print "Sorry, solution non-reachable for this board. :(\n"
        exit(0)
    initial_state = [None] * 5
    initial_state[2] = 0  # cost till state achieved
    initial_state[3] = []  # "N00" # move to find state from previous state
    initial_state[4] = copy.deepcopy(initial_board)  # board config for the state
    initial_state[1] = -heuristic_min_diagonal(initial_board)  # heuristic
    initial_state[0] = initial_state[2] - initial_state[1]  # current priority of the state
    # solution
    global start_time
    start_time = time.time()
    solution = solve_15_puzzle(initial_state)
    # print "nodes visited = %d" % nodes
    # print "fringe length = %d" % len(fringe)
    # print "visited length = %d" % len(visited)
    # print "number of moves = %d" % len(solution[3])
    print " ".join(solution[3]) if solution else "Sorry, no solution found. :(\n"
    # print "%.9f" % (end_time - start_time) if solution else " "
except IOError:
    print "No file found.\n"
    exit(0)
except ValueError:
    print "Invalid board. Please enter valid board.\n"
    exit(0)